import{_ as e,o,c as n,e as t}from"./app-BihAYnmf.js";const r={},p=t('<p>@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。</p><p>@Scope注解 作用域</p><p>@Lazy(true) 表示延迟初始化</p><p>@Service用于标注业务层组件、</p><p>@Controller用于标注控制层组件@Repository用于标注数据访问组件，即DAO组件。</p><p>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Scope用于指定scope作用域的（用在类上）</p><p>@PostConstruct用于指定初始化方法（用在方法上）</p><p>@PreDestory用于指定销毁方法（用在方法上）</p><p>@DependsOn：定义Bean初始化及销毁时的顺序</p><p>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</p><p>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下：</p><p>@Autowired @Qualifier(&quot;personDaoBean&quot;) 存在多个实例配合使用</p><p>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p><h3 id="spring中的这几个注解有什么区别-component-、-repository、-service、-controller" tabindex="-1"><a class="header-anchor" href="#spring中的这几个注解有什么区别-component-、-repository、-service、-controller"><span>Spring中的这几个注解有什么区别：@Component 、@Repository、@Service、@Controller</span></a></h3><ol><li>@Component指的是组件，</li></ol><p>@Controller，@Repository和@Service 注解都被@Component修饰，用于代码中区分表现层，持久层和业务层的组件，代码中组件不好归类时可以使用@Component来标注</p><ol start="2"><li>当前版本只有区分的作用，未来版本可能会添加更丰富的功能</li></ol>',18),i=[p];function a(s,c){return o(),n("div",null,i)}const m=e(r,[["render",a],["__file","annotation-in-spring.html.vue"]]),d=JSON.parse('{"path":"/docs/java/java-basic/annotation-in-spring.html","title":"基础","lang":"en-US","frontmatter":{"title":"基础"},"headers":[{"level":3,"title":"Spring中的这几个注解有什么区别：@Component 、@Repository、@Service、@Controller","slug":"spring中的这几个注解有什么区别-component-、-repository、-service、-controller","link":"#spring中的这几个注解有什么区别-component-、-repository、-service、-controller","children":[]}],"git":{"createdTime":1715384499000,"updatedTime":1715385524000,"contributors":[{"name":"dong","email":"dwx_job@163.com","commits":2}]},"filePathRelative":"docs/java/java-basic/annotation-in-spring.md"}');export{m as comp,d as data};
