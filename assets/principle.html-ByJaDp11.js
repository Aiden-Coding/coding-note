import{_ as e,o as i,c as p,e as n}from"./app-BihAYnmf.js";const l={},r=n('<p>面向对象开发范式的最大的好处就是易用、易扩展、易维护，但是，什么样的代码是易用、易扩展、易维护的呢？如何衡量他们呢？</p><p>罗伯特·C·马丁在21世纪早期提出了SOLID原则，这是五个原则的缩写的组合，这五个原则沿用至今。</p><h3 id="单一职责原则-single-responsibility-principle" tabindex="-1"><a class="header-anchor" href="#单一职责原则-single-responsibility-principle"><span>单一职责原则（Single-Responsibility Principle）</span></a></h3><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。</p><p>单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p><h3 id="开放封闭原则-open-closed-principle" tabindex="-1"><a class="header-anchor" href="#开放封闭原则-open-closed-principle"><span>开放封闭原则（Open-Closed principle）</span></a></h3><p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。</p><p>开放封闭原则主要体现在两个方面：</p><p>1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。</p><p>2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</p><p>实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p><h3 id="里氏替换原则-liskov-substitution-principle" tabindex="-1"><a class="header-anchor" href="#里氏替换原则-liskov-substitution-principle"><span>里氏替换原则（Liskov-Substitution Principle）</span></a></h3><p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。</p><p>在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 里氏替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。</p><p>里氏替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。</p><p>里氏替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p><h3 id="依赖倒置原则-dependecy-inversion-principle" tabindex="-1"><a class="header-anchor" href="#依赖倒置原则-dependecy-inversion-principle"><span>依赖倒置原则（Dependecy-Inversion Principle）</span></a></h3><p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。</p><p>我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。</p><p>依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p><h3 id="接口隔离原则-interface-segregation-principle" tabindex="-1"><a class="header-anchor" href="#接口隔离原则-interface-segregation-principle"><span>接口隔离原则（Interface-Segregation Principle）</span></a></h3><p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。</p><p>具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。</p><p>接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：</p><p>1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。</p><p>2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p><p>以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。</p><p>不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”</p><p>很多人刚开始可能对这些原则无法深刻的理解，但是没关系，随着自己开发经验的增长，就会慢慢的可以理解这些原则了。</p>',29),s=[r];function t(c,a){return i(),p("div",null,s)}const d=e(l,[["render",t],["__file","principle.html.vue"]]),h=JSON.parse('{"path":"/docs/java/object-oriented/principle.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"单一职责原则（Single-Responsibility Principle）","slug":"单一职责原则-single-responsibility-principle","link":"#单一职责原则-single-responsibility-principle","children":[]},{"level":3,"title":"开放封闭原则（Open-Closed principle）","slug":"开放封闭原则-open-closed-principle","link":"#开放封闭原则-open-closed-principle","children":[]},{"level":3,"title":"里氏替换原则（Liskov-Substitution Principle）","slug":"里氏替换原则-liskov-substitution-principle","link":"#里氏替换原则-liskov-substitution-principle","children":[]},{"level":3,"title":"依赖倒置原则（Dependecy-Inversion Principle）","slug":"依赖倒置原则-dependecy-inversion-principle","link":"#依赖倒置原则-dependecy-inversion-principle","children":[]},{"level":3,"title":"接口隔离原则（Interface-Segregation Principle）","slug":"接口隔离原则-interface-segregation-principle","link":"#接口隔离原则-interface-segregation-principle","children":[]}],"git":{"createdTime":1715384499000,"updatedTime":1715384499000,"contributors":[{"name":"dong","email":"dwx_job@163.com","commits":1}]},"filePathRelative":"docs/java/object-oriented/principle.md"}');export{d as comp,h as data};
