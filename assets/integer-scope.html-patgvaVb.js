import{_ as t,o as e,c as o,e as n}from"./app-BihAYnmf.js";const p={},a=n(`<p>Java中的整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p><p>先来个简单的科普，1字节=8位（bit）。java中的整型属于有符号数。</p><p>先来看计算中8bit可以表示的数字：</p><p>最小值：10000000 （-128）(-2^7)</p><p>最大值：01111111（127）(2^7-1)</p><p>整型的这几个类型中，</p><p>byte：byte用1个字节来存储，范围为-128(-2^7)到127(2^7-1)，在变量初始化的时候，byte类型的默认值为0。</p><p>short：short用2个字节存储，范围为-32,768 (-2^15)到32,767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。</p><p>int：int用4个字节存储，范围为-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)，在变量初始化的时候，int类型的默认值为0。</p><p>long：long用8个字节存储，范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。</p><p>上面说过了，整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：</p><pre><code>    int i = Integer.MAX_VALUE;
    int j = Integer.MAX_VALUE;

    int k = i + j;
    System.out.println(&quot;i (&quot; + i + &quot;) + j (&quot; + j + &quot;) = k (&quot; + k + &quot;)&quot;);
</code></pre><p>输出结果：<code>i (2147483647) + j (2147483647) = k (-2)</code></p><p>这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。</p>`,14),i=[a];function c(r,s){return e(),o("div",null,i)}const l=t(p,[["render",c],["__file","integer-scope.html.vue"]]),_=JSON.parse('{"path":"/docs/java/java-basic/integer-scope.html","title":"","lang":"en-US","frontmatter":{},"headers":[],"git":{"createdTime":1715384499000,"updatedTime":1715384499000,"contributors":[{"name":"dong","email":"dwx_job@163.com","commits":1}]},"filePathRelative":"docs/java/java-basic/integer-scope.md"}');export{l as comp,_ as data};
