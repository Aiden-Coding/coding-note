import{_ as e,o as a,c as n,e as t}from"./app-BihAYnmf.js";const p={},o=t('<p>@Override 表示当前方法覆盖了父类的方法</p><p>@Deprecated 表示方法已经过时,方法上有横线，使用时会有警告。</p><p>@SuppressWarnings 表示关闭一些警告信息(通知java编译器忽略特定的编译警告)</p><p>@SafeVarargs (jdk1.7更新) 表示：专门为抑制“堆污染”警告提供的。</p><p>@FunctionalInterface (jdk1.8更新) 表示：用来指定某个接口必须是函数式接口，否则就会编译出错。</p><h3 id="spring常用注解" tabindex="-1"><a class="header-anchor" href="#spring常用注解"><span>Spring常用注解</span></a></h3><p>@Configuration把一个类作为一个IoC容器，它的某个方法头上如果注册了@Bean，就会作为这个Spring容器中的Bean。</p><p>@Scope注解 作用域</p><p>@Lazy(true) 表示延迟初始化</p><p>@Service用于标注业务层组件</p><p>@Controller用于标注控制层组件@Repository用于标注数据访问组件，即DAO组件。</p><p>@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。</p><p>@Scope用于指定scope作用域的（用在类上）</p><p>@PostConstruct用于指定初始化方法（用在方法上）</p><p>@PreDestory用于指定销毁方法（用在方法上）</p><p>@DependsOn：定义Bean初始化及销毁时的顺序</p><p>@Primary：自动装配时当出现多个Bean候选者时，被注解为@Primary的Bean将作为首选者，否则将抛出异常</p><p>@Autowired 默认按类型装配，如果我们想使用按名称装配，可以结合@Qualifier注解一起使用。如下： @Autowired @Qualifier(&quot;personDaoBean&quot;) 存在多个实例配合使用</p><p>@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。</p><p>@PostConstruct 初始化注解</p><p>@PreDestroy 摧毁注解 默认 单例 启动就加载</p>',21),r=[o];function i(s,c){return a(),n("div",null,r)}const l=e(p,[["render",i],["__file","annotation-in-java.html.vue"]]),m=JSON.parse('{"path":"/docs/java/java-basic/annotation-in-java.html","title":"注解","lang":"en-US","frontmatter":{"title":"注解"},"headers":[{"level":3,"title":"Spring常用注解","slug":"spring常用注解","link":"#spring常用注解","children":[]}],"git":{"createdTime":1715384499000,"updatedTime":1715385524000,"contributors":[{"name":"dong","email":"dwx_job@163.com","commits":2}]},"filePathRelative":"docs/java/java-basic/annotation-in-java.md"}');export{l as comp,m as data};
