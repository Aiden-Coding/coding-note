import{_ as t,o as e,c as r,e as o}from"./app-BihAYnmf.js";const s={},a=o(`<p>在Java中，集合和数组是我们经常会用到的数据结构，需要经常对他们做增、删、改、查、聚合、统计、过滤等操作。相比之下，关系型数据库中也同样有这些操作，但是在Java 8之前，集合和数组的处理并不是很便捷。</p><p>不过，这一问题在Java 8中得到了改善，Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。本文就来介绍下如何使用Stream。特别说明一下，关于Stream的性能及原理不是本文的重点，如果大家感兴趣后面会出文章单独介绍。</p><h3 id="stream介绍" tabindex="-1"><a class="header-anchor" href="#stream介绍"><span>Stream介绍</span></a></h3><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</p><p>Stream有以下特性及优点：</p><ul><li>无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li><li>为函数式编程而生。对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li><li>惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li><li>可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li></ul><p>我们举一个例子，来看一下到底Stream可以做什么事情：</p><p><img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15521192454583.jpg" alt="">￼</p><p>上面的例子中，获取一些带颜色塑料球作为数据源，首先过滤掉红色的、把它们融化成随机的三角形。再过滤器并删除小的三角形。最后计算出剩余图形的周长。</p><p>如上图，对于流的处理，主要有三种关键性操作：分别是流的创建、中间操作（intermediate operation）以及最终操作(terminal operation)。</p><h3 id="stream的创建" tabindex="-1"><a class="header-anchor" href="#stream的创建"><span>Stream的创建</span></a></h3><p>在Java 8中，可以有多种方法来创建流。</p><p><strong>1、通过已有的集合来创建流</strong></p><p>在Java 8中，除了增加了很多Stream相关的类以外，还对集合类自身做了增强，在其中增加了stream方法，可以将一个集合类转换成流。</p><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;Hollis&quot;, &quot;HollisChuang&quot;, &quot;hollis&quot;, &quot;Hello&quot;, &quot;HelloWorld&quot;, &quot;Hollis&quot;);
Stream&lt;String&gt; stream = strings.stream();
</code></pre><p>以上，通过一个已有的List创建一个流。除此以外，还有一个parallelStream方法，可以为集合创建一个并行流。</p><p>这种通过集合创建出一个Stream的方式也是比较常用的一种方式。</p><p><strong>2、通过Stream创建流</strong></p><p>可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。</p><pre><code>Stream&lt;String&gt; stream = Stream.of(&quot;Hollis&quot;, &quot;HollisChuang&quot;, &quot;hollis&quot;, &quot;Hello&quot;, &quot;HelloWorld&quot;, &quot;Hollis&quot;);
</code></pre><p>如以上代码，直接通过of方法，创建并返回一个Stream。</p><h3 id="stream中间操作" tabindex="-1"><a class="header-anchor" href="#stream中间操作"><span>Stream中间操作</span></a></h3><p>Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p><p><img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15521194075219.jpg" alt="">￼</p><p>以下是常用的中间操作列表:</p><p><img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15521194556484.jpg" alt="">￼</p><p><strong>filter</strong></p><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤掉空字符串：</p><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;Hollis&quot;, &quot;&quot;, &quot;HollisChuang&quot;, &quot;H&quot;, &quot;hollis&quot;);
strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);
//Hollis, HollisChuang, H, hollis
</code></pre><p><strong>map</strong></p><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
numbers.stream().map(i -&gt; i*i).forEach(System.out::println);
//9,4,4,9,49,9,25
</code></pre><p><strong>limit/skip</strong></p><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。以下代码片段使用 limit 方法保留4个元素：</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
numbers.stream().limit(4).forEach(System.out::println);
//3,2,2,3
</code></pre><p><strong>sorted</strong></p><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法进行排序：</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
numbers.stream().sorted().forEach(System.out::println);
//2,2,3,3,3,5,7
</code></pre><p><strong>distinct</strong></p><p>distinct主要用来去重，以下代码片段使用 distinct 对元素进行去重：</p><pre><code>List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5);
numbers.stream().distinct().forEach(System.out::println);
//3,2,7,5
</code></pre><p>接下来我们通过一个例子和一张图，来演示下，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会发生什么。</p><p>代码如下：</p><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;Hollis&quot;, &quot;HollisChuang&quot;, &quot;hollis&quot;, &quot;Hello&quot;, &quot;HelloWorld&quot;, &quot;Hollis&quot;);
Stream s = strings.stream().filter(string -&gt; string.length()&lt;= 6).map(String::length).sorted().limit(3)
            .distinct();
</code></pre><p>过程及每一步得到的结果如下图：</p><p><img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15521242025506.jpg" alt="">￼</p><h3 id="stream最终操作" tabindex="-1"><a class="header-anchor" href="#stream最终操作"><span>Stream最终操作</span></a></h3><p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流转换成集合等。这就需要最终操作（terminal operation）</p><p>最终操作会消耗流，产生一个最终结果。也就是说，在最终操作之后，不能再次使用流，也不能再使用任何中间操作，否则将抛出异常：</p><pre><code>java.lang.IllegalStateException: stream has already been operated upon or closed
</code></pre><p>俗话说，“你永远不会两次踏入同一条河”也正是这个意思。</p><p>常用的最终操作如下图：</p><p><img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15521194606851.jpg" alt="">￼</p><p><strong>forEach</strong></p><p>Stream 提供了方法 &#39;forEach&#39; 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p><pre><code>Random random = new Random();
random.ints().limit(10).forEach(System.out::println);
</code></pre><p><strong>count</strong></p><p>count用来统计流中的元素个数。</p><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;Hollis&quot;, &quot;HollisChuang&quot;, &quot;hollis&quot;, &quot;Hollis666&quot;, &quot;Hello&quot;, &quot;HelloWorld&quot;, &quot;Hollis&quot;);
System.out.println(strings.stream().count());
//7
</code></pre><p><strong>collect</strong></p><p>collect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果：</p><pre><code>List&lt;String&gt; strings = Arrays.asList(&quot;Hollis&quot;, &quot;HollisChuang&quot;, &quot;hollis&quot;,&quot;Hollis666&quot;, &quot;Hello&quot;, &quot;HelloWorld&quot;, &quot;Hollis&quot;);
strings  = strings.stream().filter(string -&gt; string.startsWith(&quot;Hollis&quot;)).collect(Collectors.toList());
System.out.println(strings);
//Hollis, HollisChuang, Hollis666, Hollis
</code></pre><p>接下来，我们还是使用一张图，来演示下，前文的例子中，当一个Stream先后通过filter、map、sort、limit以及distinct处理后，在分别使用不同的最终操作可以得到怎样的结果：</p><p>下图，展示了文中介绍的所有操作的位置、输入、输出以及使用一个案例展示了其结果。 <img src="https://www.hollischuang.com/wp-content/uploads/2019/03/15521245463720.jpg" alt="">￼</p><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>本文介绍了Java 8中的Stream 的用途，优点等。还介绍了Stream的几种用法，分别是Stream创建、中间操作和最终操作。</p><p>Stream的创建有两种方式，分别是通过集合类的stream方法、通过Stream的of方法。</p><p>Stream的中间操作可以用来处理Stream，中间操作的输入和输出都是Stream，中间操作可以是过滤、转换、排序等。</p><p>Stream的最终操作可以将Stream转成其他形式，如计算出流中元素的个数、将流转换成集合、以及元素的遍历等。</p>`,71),l=[a];function n(i,p){return e(),r("div",null,l)}const u=t(s,[["render",n],["__file","stream.html.vue"]]),c=JSON.parse('{"path":"/docs/java/java-basic/stream.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":3,"title":"Stream介绍","slug":"stream介绍","link":"#stream介绍","children":[]},{"level":3,"title":"Stream的创建","slug":"stream的创建","link":"#stream的创建","children":[]},{"level":3,"title":"Stream中间操作","slug":"stream中间操作","link":"#stream中间操作","children":[]},{"level":3,"title":"Stream最终操作","slug":"stream最终操作","link":"#stream最终操作","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":1715384499000,"updatedTime":1715384499000,"contributors":[{"name":"dong","email":"dwx_job@163.com","commits":1}]},"filePathRelative":"docs/java/java-basic/stream.md"}');export{u as comp,c as data};
