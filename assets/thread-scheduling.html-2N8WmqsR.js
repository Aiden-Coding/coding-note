import{_ as a,o as e,c as n,e as i}from"./app-BihAYnmf.js";const t={},s=i('<p>在关于线程安全的文章中，我们提到过，对于单CPU的计算机来说，在任意时刻只能执行一条机器指令，每个线程只有获得CPU的使用权才能执行指令。</p><p>所谓多线程的并发运行，其实是指从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。</p><p>前面关于线程状态的介绍中，我们知道，线程的运行状态中包含两种子状态，即就绪（READY）和运行中(RUNNING)。</p><p>而一个线程想要从就绪状态变成运行中状态，这个过程需要系统调度，即给线程分配CPU的使用权，获得CPU使用权的线程才会从就绪状态变成运行状态。</p><p><strong>给多个线程按照特定的机制分配CPU的使用权的过程就叫做线程调度。</strong></p><p>还记得在介绍进程和线程的区别的时候，我们提到过的一句话吗：进程是分配资源的基本单元，线程是CPU调度的基本单元。这里所说的调度指的就是给其分配CPU时间片，让其执行任务。</p><h2 id="linux线程调度" tabindex="-1"><a class="header-anchor" href="#linux线程调度"><span>Linux线程调度</span></a></h2><p>在Linux中，线程是由进程来实现，线程就是轻量级进程（ lightweight process ），因此在Linux中，线程的调度是按照进程的调度方式来进行调度的，也就是说线程是调度单元。</p><p>Linux这样实现的线程的好处的之一是：线程调度直接使用进程调度就可以了，没必要再搞一个进程内的线程调度器。在Linux中，调度器是基于线程的调度策略（scheduling policy）和静态调度优先级（static scheduling priority）来决定那个线程来运行。</p><p>在Linux中，主要有三种调度策略。分别是：</p><ul><li>SCHED_OTHER 分时调度策略，（默认的）</li><li>SCHED_FIFO 实时调度策略，先到先服务</li><li>SCHED_RR 实时调度策略，时间片轮转</li></ul><h2 id="windows线程调度" tabindex="-1"><a class="header-anchor" href="#windows线程调度"><span>Windows线程调度</span></a></h2><p>Windows 采用基于优先级的、抢占调度算法来调度线程。</p><p>用于处理调度的 Windows 内核部分称为调度程序，Windows 调度程序确保具有最高优先级的线程总是在运行的。由于调度程序选择运行的线程会一直运行，直到被更高优先级的线程所抢占，或终止，或时间片已到，或调用阻塞系统调用（如 I/O）。如果在低优先级线程运行时，更高优先级的实时线程变成就绪，那么低优先级线程就被抢占。这种抢占使得实时线程在需要使用 CPU 时优先得到使用。</p><h1 id="java线程调度" tabindex="-1"><a class="header-anchor" href="#java线程调度"><span>Java线程调度</span></a></h1><p>可以看到，不同的操作系统，有不同的线程调度策略。但是，作为一个Java开发人员来说，我们日常开发过程中一般很少关注操作系统层面的东西。</p><p>主要是因为Java程序都是运行在Java虚拟机上面的，而虚拟机帮我们屏蔽了操作系统的差异，所以我们说Java是一个跨平台语言。</p><p><strong>在操作系统中，一个Java程序其实就是一个进程。所以，我们说Java是单进程、多线程的！</strong></p><p>前面关于线程的实现也介绍过，Thread类与大部分的Java API有显著的差别，它的所有关键方法都是声明为Native的，也就是说，他需要根据不同的操作系统有不同的实现。</p><p>在Java的多线程程序中，为保证所有线程的执行能按照一定的规则执行，JVM实现了一个线程调度器，它定义了线程调度模型，对于CPU运算的分配都进行了规定，按照这些特定的机制为多个线程分配CPU的使用权。</p><p>主要有两种调度模型：<strong>协同式线程调度</strong>和<strong>抢占式调度模型</strong>。</p><h2 id="协同式线程调度" tabindex="-1"><a class="header-anchor" href="#协同式线程调度"><span>协同式线程调度</span></a></h2><p>协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以没有什么线程同步的问题。</p><h2 id="抢占式调度模型" tabindex="-1"><a class="header-anchor" href="#抢占式调度模型"><span>抢占式调度模型</span></a></h2><p>抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。在这种实现线程调度的方式下，线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题。</p><p>系统会让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。</p><p><strong>Java虚拟机采用抢占式调度模型。</strong></p><p>虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点——这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行。</p><p>不过，线程优先级并不是太靠谱，原因是Java的线程是通过映射到系统的原生线程上来实现的，所以线程调度最终还是取决于操作系统，虽然现在很多操作系统都提供线程优先级的概念，但是并不见得能与Java线程的优先级一一对应。</p>',29),p=[s];function l(r,d){return e(),n("div",null,p)}const c=a(t,[["render",l],["__file","thread-scheduling.html.vue"]]),h=JSON.parse('{"path":"/docs/java/concurrent-coding/thread-scheduling.html","title":"线程调度","lang":"en-US","frontmatter":{"title":"线程调度"},"headers":[{"level":2,"title":"Linux线程调度","slug":"linux线程调度","link":"#linux线程调度","children":[]},{"level":2,"title":"Windows线程调度","slug":"windows线程调度","link":"#windows线程调度","children":[]},{"level":2,"title":"协同式线程调度","slug":"协同式线程调度","link":"#协同式线程调度","children":[]},{"level":2,"title":"抢占式调度模型","slug":"抢占式调度模型","link":"#抢占式调度模型","children":[]}],"git":{"createdTime":1715384499000,"updatedTime":1715385399000,"contributors":[{"name":"dong","email":"dwx_job@163.com","commits":2}]},"filePathRelative":"docs/java/concurrent-coding/thread-scheduling.md"}');export{c as comp,h as data};
